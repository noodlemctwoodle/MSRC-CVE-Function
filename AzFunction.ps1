# Import the System.Net namespace for HTTP functionality
using namespace System.Net

# Define parameters passed in via the param block.
param($Request, $TriggerMetadata)

# Extract 'name' from the Request parameters, if not available, retrieve it from the Request body
$name = $Request.Query.Name
if (-not $name) {
    $name = $Request.Body.Name
}

# Extract 'date' from the Request parameters, if not available, retrieve it from the Request body
$date = $Request.Query.Date
if (-not $date) {
    $date = $Request.Body.Date
}

if (-not $date) {
    # Retrieve 'date' from the Microsoft API using 'name'
    $aliasResponse = Invoke-RestMethod -Uri ("https://api.msrc.microsoft.com/cvrf/v2.0/Updates('" + $name + "')")
    if ($aliasResponse -and $aliasResponse.value -and $aliasResponse.value.Count -gt 0) {
        $date = $aliasResponse.value[0].Alias
    } else {
        Write-Host "Alias not found in the API response"
    }
}

# Send a GET request to the Microsoft API to get the CVE details. The API endpoint changes according to the 'date' parameter
$response = (Invoke-WebRequest ("https://api.msrc.microsoft.com/cvrf/" + $date) -Headers @{Accept = "application/json" }).Content | ConvertFrom-Json -Depth 99

# Filter out the specific vulnerability details we want from the response, based on the 'name' parameter
$CVE = $response.Vulnerability | Where-Object CVE -EQ $name

# Split exploitability details into an array of key-value pairs
$Exploitability = $cve.Threats | Where-Object Type -EQ 1 | ForEach-Object {
    $exploitDetails = $_.description.value -split ";"
    $exploitHashTable = @{}
    foreach ($detail in $exploitDetails) {
        $keyValue = $detail -split ":", 2
        if ($keyValue.Count -eq 2) {
            $exploitHashTable[$keyValue[0].Trim()] = $keyValue[1].Trim()
        }
    }
    $exploitHashTable
}

# Create a custom object to represent the CVE data we're interested in
$CVEObject = [PSCustomObject]@{
    CVE            = $CVE.CVE
    Title          = $CVE.Title.Value
    Description    = ($cve.Notes.Value -replace "<.*?>", "" -split "\\n" | ForEach-Object { $_.Trim() }) -join "`r`n"
    CVSSBaseScore  = ($cve.CVSSScoreSets | Group-Object -Property BaseScore -NoElement).Name
    Exploitability = $Exploitability
    Mitigations    = ($cve.Remediations | Where-Object type -EQ 1).description.value -replace "<.*?>", "" -replace "\\n","`r`n"
    Revisions      = $cve.RevisionHistory
    Impact         = ($CVE.Threats.Description.Value | Select-Object -Unique | Where-Object { $_ -ne "Important" -and $_ -notlike "*;*" })
}

# Convert CVE data to JSON for output, or give appropriate error messages if data is not available
if ($CVEObject) {
    $body = ConvertTo-Json -InputObject $CVEObject -Depth 99
} elseif (-not $CVEObject) {
    $body = "CVE not found"
} else {
    Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::NoContent
            Body       = "No valid CVE provided"
        })
}

# Pass the final response to the output bindings
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = $body
    })
