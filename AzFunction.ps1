# Import the System.Net namespace for HTTP functionality
using namespace System.Net

# Define parameters passed in via the param block.
param($Request, $TriggerMetadata)

# Extract 'name' from the Request parameters, if not available, retrieve it from the Request body
$name = $Request.Query.Name
if (-not $name) {
    $name = $Request.Body.Name
}

# Extract 'date' from the Request parameters, if not available, retrieve it from the Request body
$date = $Request.Query.Date
if (-not $date) {
    $date = $Request.Body.Date
}

# Extract 'api' from the Request parameters, if not available, retrieve it from the Request body
$api = $Request.Query.API
if (-not $api) {
    $api = $Request.Body.API
}

#NIST API Key
$apiKey = "11111-11111-111111-1111111"

function Get-MSVulnerability {
    param (
        $date,
        $name
    )
    
    if (-not $date) {
        # Retrieve 'date' from the Microsoft API using 'name'
        $aliasResponse = Invoke-RestMethod -Uri ("https://api.msrc.microsoft.com/cvrf/v2.0/Updates('" + $name + "')")
        if ($aliasResponse -and $aliasResponse.value -and $aliasResponse.value.Count -gt 0) {
            $date = $aliasResponse.value[0].Alias
        }
        else {
            Write-Error "Alias not found in the API response"
            return
        }
    }

    # Send a GET request to the Microsoft API to get the CVE details.
    $response = (Invoke-WebRequest ("https://api.msrc.microsoft.com/cvrf/" + $date) -Headers @{Accept = "application/json" }).Content | ConvertFrom-Json -Depth 99

    # Filter out the specific vulnerability details we want from the response
    $CVE = $response.Vulnerability | Where-Object CVE -EQ $name

    # Split exploitability details into an array of key-value pairs
    $Exploitability = $CVE.Threats | Where-Object Type -EQ 1 | ForEach-Object {
        $exploitDetails = $_.description.value -split ";"
        $exploitHashTable = @{}
        foreach ($detail in $exploitDetails) {
            $keyValue = $detail -split ":", 2
            if ($keyValue.Count -eq 2) {
                $exploitHashTable[$keyValue[0].Trim()] = $keyValue[1].Trim()
            }
        }
        $exploitHashTable
    }

    # Create a custom object to represent the CVE data we're interested in
    $MSVulnerabilityObject = [PSCustomObject]@{
        CVE            = $CVE.CVE
        Title          = $CVE.Title.Value
        Description    = ($CVE.Notes.Value -replace "<.*?>", "" -split "\\n" | ForEach-Object { $_.Trim() }) -join "`r`n"
        CVSSBaseScore  = ($CVE.CVSSScoreSets | Group-Object -Property BaseScore -NoElement).Name
        Exploitability = $Exploitability
        Mitigations    = ($CVE.Remediations | Where-Object type -EQ 1).description.value -replace "<.*?>", "" -replace "\\n", "`r`n"
        Revisions      = $CVE.RevisionHistory
        Impact         = ($CVE.Threats.Description.Value | Select-Object -Unique | Where-Object { $_ -ne "Important" -and $_ -notlike "*;*" })
    }

    return $MSVulnerabilityObject
}

function Get-NISTVulnerability {
    param(
        [Parameter(Mandatory = $true)]
        [string]$name,

        [Parameter(Mandatory = $true)]
        [string]$apiKey
    )

    # Function to convert properties to individual keys
    function ConvertPropertiesToIndividualKeys($metrics) {
        $result = @{}
        $metrics.PSObject.Properties | ForEach-Object {
            $result[$_.Name] = $_.Value
        }
        return $result
    }
    
    # Make request to the NIST API
    $nist = (Invoke-WebRequest -Uri "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=$name" -Headers @{Accept = "application/json"; Key = $apiKey }).Content | ConvertFrom-Json -Depth 99
    
    # If no results, return null
    if ($nist.totalResults -eq 0) {
        return $null
    }
    
    # Process data from the NIST API
    $vulnerability = $nist.vulnerabilities[0]
    $metricsV2 = $vulnerability.cve.metrics.cvssMetricV2[0]
    $metricsV2Properties = ConvertPropertiesToIndividualKeys $metricsV2.cvssData
    
    # List of additional properties
    $additionalProperties = @("baseSeverity", "exploitabilityScore", "impactScore", "acInsufInfo", "obtainAllPrivilege", "obtainUserPrivilege", "obtainOtherPrivilege", "userInteractionRequired")
    
    # Add the additional properties to the $metricsV2Properties
    foreach ($property in $additionalProperties) {
        $metricsV2Properties.$property = $metricsV2.$property
    }
    
    $metricsV31Properties = ConvertPropertiesToIndividualKeys $vulnerability.cve.metrics.cvssMetricV31[0].cvssData
    
    # Process URLs and tags from references
    $urls = @()
    $tags = @()
    foreach ($reference in $vulnerability.cve.references) {
        $urls += $reference.url
        $tags += $reference.tags
    }
    $urls = $urls | Sort-Object | Get-Unique
    $tags = $tags | Sort-Object | Get-Unique
    
    # Create a custom object with processed data
    $NISTVulnerabilityObject = [PSCustomObject]@{
        id                      = $vulnerability.cve.id
        baseScore               = $metricsV31Properties.baseScore
        impactScore             = $metricsV2Properties.impactScore
        exploitabilityScore     = $metricsV2Properties.exploitabilityScore
        baseSeverity            = $metricsV2Properties.baseSeverity
        sourceIdentifier        = $vulnerability.cve.sourceIdentifier
        published               = $vulnerability.cve.published
        lastModified            = $vulnerability.cve.lastModified
        vulnStatus              = $vulnerability.cve.vulnStatus
        scope                   = $metricsV31Properties.scope
        referenceTags           = $tags -join ", "
        descriptions            = ($vulnerability.cve.descriptions | Where-Object { $_.lang -eq 'en' })[0].value
        configurations          = $vulnerability.cve.configurations[0].nodes -join ", "
        weaknesses              = ($vulnerability.cve.weaknesses | ForEach-Object { $_.description | Where-Object { $_.lang -eq 'en' } | ForEach-Object { $_.value } }) -join ", "
        accessVector            = $metricsV2Properties.accessVector
        accessComplexity        = $metricsV2Properties.accessComplexity
        attackVector            = $metricsV31Properties.attackVector
        attackComplexity        = $metricsV31Properties.attackComplexity
        authentication          = $metricsV2Properties.authentication
        privilegesRequired      = $metricsV31Properties.privilegesRequired
        acInsufInfoV2           = $metricsV2Properties.acInsufInfo
        obtainAllPrivilege      = $metricsV2Properties.obtainAllPrivilege
        obtainUserPrivilege     = $metricsV2Properties.obtainUserPrivilege
        obtainOtherPrivilege    = $metricsV2Properties.obtainOtherPrivilege
        userInteractionRequired = $metricsV2Properties.userInteractionRequired
        integrityImpact         = $metricsV31Properties.integrityImpact
        availabilityImpact      = $metricsV31Properties.availabilityImpact
        confidentialityImpact   = $metricsV31Properties.confidentialityImpact
        userInteraction         = $metricsV31Properties.userInteraction
        vectorString            = $metricsV31Properties.vectorString
        referenceUrls           = $urls -join ", "  
    }
    return $NISTVulnerabilityObject
}


if ($api -eq 'MS') {
    $vulnerabilityObject = Get-MSVulnerability -name $name -date $date
}
elseif ($api -eq 'NIST') {
    $vulnerabilityObject = Get-NISTVulnerability -name $name -apiKey $apiKey
}
else {
    Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::BadRequest
            Body       = "Invalid API specified. Please specify either 'MS' or 'NIST'"
        })
    return
}

# Convert CVE data to JSON for output, or give appropriate error messages if data is not available
if ($vulnerabilityObject) {
    $body = ConvertTo-Json -InputObject $vulnerabilityObject -Depth 99
}
elseif (-not $vulnerabilityObject) {
    $body = "CVE not found"
}
else {
    Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
            StatusCode = [HttpStatusCode]::NoContent
            Body       = "No valid CVE provided"
        })
}

# Pass the final response to the output bindings
Push-OutputBinding -Name Response -Value ([HttpResponseContext]@{
        StatusCode = [HttpStatusCode]::OK
        Body       = $body
    })
